1. Single Codebase + Resource Files
Key-based strings
Every piece of text in your UI is replaced by a lookup key (e.g. button.submit).

Locale bundles
For each supported language you maintain a resource file (JSON, YAML, PO, etc.) mapping those keys to translated text.

jsonc
Copy
Edit
// en.json
{ "button.submit": "Submit" }
// ja.json
{ "button.submit": "送信" }
Runtime or build-time loading
At build time (e.g. Next.js) or runtime (e.g. i18next in React/Vue), the correct bundle is injected based on user choice or browser locale.

This avoids duplicating entire components: your UI references the same keys everywhere, so you only swap in different strings.

2. Translation Management Systems (TMS)
Hand-editing flat files soon becomes unmanageable as you add pages and languages. Instead teams use a TMS (e.g. Lokalise, Transifex, Phrase, Crowdin):

Integration with your repo
The TMS pulls new or changed keys automatically.

Centralized workflow
Translators log in, see which keys are untranslated or outdated, and provide translations in a web interface.

Versioning & QA
Built-in checks flag missing variables (e.g. %{count}), inconsistent lengths, or untranslated segments.

Pull back translations
Once approved, the translated bundles are pushed back into your codebase or deployed directly.

3. Leveraging Machine Translation + Post-Editing
Draft with AI
Services like DeepL, Google Translate, or AWS Translate can pre-fill translations in your TMS.

Human review required
Pure MT is fast but error-prone. Professional teams use MT to cut down the initial workload, then editors correct nuances, brand voice, and context.

Translation memory (TM)
The TMS stores previously approved translations so identical phrases aren’t re-translated every time.

4. Ongoing Maintenance Practices
Continuous localization
Whenever developers add or change a key, it flows automatically into your TMS and flags translators—no manual file juggling.

Fallbacks & partial coverage
Untranslated keys fall back to a default language (e.g. English) so you never ship missing text.

Contextual metadata
Attach screenshots or usage notes to each key so translators know where and how the text appears.

Periodic audits
Use automated tests (linting tools for i18n) to catch unused keys, missing translations, or formatting issues.

5. SEO & UX Considerations
<link rel="alternate" hreflang="…"> tags for search engines.

Locale-aware formatting for dates, numbers, currencies via the Intl API (or equivalent).

Right-to-left support if you ever add languages like Arabic or Hebrew.

Language switcher UI typically persists choice in a cookie or URL prefix (/ja/…, /en/…) so deep links work.

