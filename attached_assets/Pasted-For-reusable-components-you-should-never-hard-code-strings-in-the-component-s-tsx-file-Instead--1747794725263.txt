For reusable components you should never hard-code strings in the component’s `.tsx` file.  Instead:

1. **Extract every UI text into a translation catalog.**
   • Create one directory per language (e.g. `src/locales/en/`, `src/locales/ja/`).
   • Inside each, split by “namespace” or feature:

   ```text
   src/locales/
     en/
       common.json       ← shared UI bits (buttons, labels, placeholders…)
       cards.json        ← text only used by Card components
       animations.json   ← animation captions, alt-text…
     ja/
       common.json
       cards.json
       animations.json
   ```
2. **Use a battle-tested i18n library** (e.g. **react-i18next** or **react-intl**).
   • Initialize it once in your app root, pointing at your `src/locales` folder.
   • On language switch, it automatically loads the right JSON files.
3. **In your reusable component, reference translation keys, not strings.**

   ```tsx
   import { useTranslation } from 'react-i18next';

   export function Card() {
     const { t } = useTranslation('cards');  // loads cards.json
     return (
       <article>
         <h2>{t('title')}</h2>
         <p>{t('description')}</p>
         <button>{t('actions.learnMore')}</button>
       </article>
     );
   }
   ```
4. **For on-going content (blogs, whitepapers), treat them as a separate namespace or even a CMS/**Markdown** pipeline.**
   • If you’re using Markdown, you can keep a directory for each language:

   ```
   content/
     en/articles/2025-05-21-whatever.md
     ja/articles/2025-05-21-whatever.md
   ```

   • Your page loader picks the right folder based on the current locale.
5. **Advantages of this structure**

   * Keeps translation cleanly separated from component logic.
   * Makes it trivial to hand off to translators (they never open `.tsx`).
   * Enables code-splitting: you only bundle the JSON for the active language.
   * Supports namespacing (so you don’t end up with a 10,000-key monolithic file).

**Summary**
– Don’t inline strings in your TS files.
– Store all copy in external JSON/MD files organized by language and feature.
– Consume them via a standard i18n library (react-i18next, react-intl, etc.).

That’s the industry-standard approach for both your reusable UI components and your dynamic content.
